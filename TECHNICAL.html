<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Technical overview of StealthPipe</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="technical-overview-of-stealthpipe">Technical overview of StealthPipe</h1>
<p>Here's a nice <em>technical</em> and very <em>nerdy</em> overview of StealthPipe.</p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p>Technical overview may be outdated from time to time! Documentation updated for version <strong>3.0.0</strong>. Last modified: 2025-12-28.</p>
</div>
<h3 id="a-quick-summary">A Quick Summary</h3>
<p>Just in case you came here by accident, StealthPipe is a Minecraft mod that allows Open to LAN multiplayer to work on networks that block peer-to-peer connections and non-standard ports.</p>
<p>StealthPipe creates parallel connections to the relay to optimize performance. It establishes one secure WebSocket connection (TLS/HTTPS) per player to the relay for sandboxing and stability, relaying all binary traffic to the other client. It does not (and cannot) discover what is inside each packet, since it only forwards the raw binary and does not manipulate packets. Also, by default, Minecraft traffic is end-to-end encrypted (unless using offline mode), which means StealthPipe cannot decode the traffic anyway.</p>
<h3 id="why-is-the-name-of-this-mod-stealthpipe">Why is the name of this mod StealthPipe?</h3>
<p>Let's start with the obvious. Why &quot;StealthPipe&quot;?</p>
<ul>
<li><strong>Stealth</strong>: chosen because it blends in with web traffic, essentially acting stealthily. However, in most environments where non-standard ports and P2P connections are blocked, they are doing it for security reasons (prevent SSH or other attacks), not to block Minecraft. However, if the purpose of banning non-standard ports and P2P is to block gaming, you should respect these rules. Read the other sections down below to learn more.</li>
<li><strong>Pipe</strong>: it essentially means &quot;tunnel&quot; (as in a network tunnel), passing traffic through a relay before arriving at the other client's device instead of directly sending traffic to the other client.</li>
</ul>
<h3 id="clarifying-the-description-of-stealthpipe">Clarifying the Description of StealthPipe</h3>
<p>In the description, it says &quot;can work on networks that block peer-to-peer connections and non-standard ports&quot;. What does this actually mean?</p>
<ul>
<li><strong>Works on networks blocking peer-to-peer connections</strong>: Minecraft Open to LAN requires the other client to connect to the host by using the IP address on the current network. However, in many public WiFis, peer isolation is used, which prevents devices from seeing each other on the same network. Why is this used? To prevent viruses from spreading from one device to another on the same network (lateral movement). To fix this, StealthPipe relays all Minecraft traffic to a relay so devices don't need to see each other to play together.</li>
<li><strong>Works on networks that block non-standard ports</strong>: Many public WiFis block ports that are considered non-standard to prevent malware and viruses from entering from those ports. Minecraft's allowed ports (25565) are all considered non-standard ports, which is why it is blocked on many public networks even when the purpose is not to block online gaming. To fix this, StealthPipe relays traffic using WebSockets (port 443) which is considered a standard port, since all of web technology runs on it. It's the same technology that Microsoft Word, Snapchat, Discord, Teams, Excel, Powerpoint, and many others use.</li>
</ul>
<h3 id="broad-overview-of-network-handshake">Broad overview of network handshake</h3>
<pre><code>
  Overview of the Network Handshake phases
  ┌─────────────────────────────────────────────────────┐
  │ [HOST]                  [RELAY]           [CLIENT]  │
  ├────────────────────────────┬────────────────────────┤
  │                            │                        │
  │ 1. PING wakeup ───────────&gt;│                        │
  │ 2. PoW Req (salt) ────────&gt;│                        │
  │&lt;────────── 3. Nonce &amp; diff.│                        │
  │ 4. CREATE ROOM ───────────&gt;│                        │
  │&lt;&lt;&lt;&lt;&lt;&lt; 5. OPEN SIGNAL &gt;&gt;&gt;&gt;&gt;&gt;│                        │
  │                            │                        │
  │               [ Client joins the room ]             │
  │                            │&lt;──── 6. JOIN (Room ID) │
  │&lt;─────── 7. SIGNAL REQ CONN │                        │
  │ 8. JOIN with ID ──────────&gt;│                        │
  │                            │                        │
  │            [THREADS LINKED, TUNNEL FORMED]          │
  │&lt;=======================DATA STREAM=================&gt;│
  └─────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Summary of each step</strong></p>
<ol>
<li>
<p><strong>PING wakeup</strong>: wake up the Render instance and get the game ping between another player and you (host). This is done by calling the <code>/ping</code> endpoint, which should return &quot;OK&quot; with the status code 200. If it does not return a status code of 200, it means that the instance is currently unhealthy. As a side note, the <code>/ping</code> endpoint is used as a &quot;health check&quot; endpoint. The round-trip time between you and the relay is measured by a <code>start</code> and an <code>end</code> variable, and the round-trip latency is calculated by subtracting <code>start</code> from <code>end</code>. Then, this number is multiplied by 2 to get the estimated latency between another player and you (the host), which is the game's ping. It definitely isn't very accurate, but it works for now.</p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p>As of version 4.0.0, StealthPipe will submit its current mod version to the relay, and the ping endpoint will either accept/reject version, and return an outdated message.
The reason the <code>/ping</code> endpoint is used is to maintain backward compatibility, since <code>/ping</code> is the only endpoint where the client will print its message.</p>
</div>
</li>
<li>
<p><strong>PoW Req (salt)</strong>: request a proof of work salt and token from the relay. The mod calls the <code>/pow</code> endpoint which returns a JWT token (used for validating if the challenge was actually given by the relay) that includes the salt, the difficulty, and the expiry time.</p>
</li>
<li>
<p><strong>Nonce and difficulty</strong>: Server returns the nonce, the difficulty and a validation token that will be used when creating the room.</p>
</li>
<li>
<p><strong>Create room</strong>: Using the nonce computed by the host and the proof of work validation token, the host can request the relay to create a new room. The endpoint for this is <code>/create</code>.</p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p>As of version 4.1.0, <code>/create</code> will return a reuseToken, which expires in 1 hour. It contains the token for allowing the client to re-use the same room code when it reconnects. This is used to allow the client to reconnect to the same room code when it unexpectedly disconnects because of the relay restarting.</p>
</div>
</li>
<li>
<p><strong>Open SIGNAL</strong>: Host and relay open a SIGNAL socket to communicate information such as new players trying to connect.</p>
</li>
<li>
<p><strong>Join with room ID</strong>: Another client requests the relay to join a room ID</p>
</li>
<li>
<p><strong>SIGNAL REQ CONN</strong>: Relay forwards this request to the host by sending a <code>REQUESTCONNECTION_[ROOM ID]_[REQUEST ID]</code> where the host has to use this ID to create a DATA connection between the host and the relay.</p>
</li>
<li>
<p><strong>Join with request ID</strong>: Host creates a websocket connection between the host and relay. Relay links the incoming client DATA connection to the incoming host DATA connection with the ID.</p>
</li>
<li>
<p><strong>THREADS LINKED</strong>: Sockets are successfully linked together and a tunnel is formed.</p>
</li>
</ol>
<h3 id="overview-of-networking">Overview of Networking</h3>
<p>StealthPipe's networking model uses a parallel connections model.</p>
<p>In these diagrams, <strong>DATA</strong> refers to sockets that send Minecraft packets, and <strong>SIGNAL</strong> refers to sockets that send signals needed for state management (such as detecting a new player trying to connect). However, in other implementations, DATA  is used as a signaling socket AND as a data socket.</p>
<p>In StealthPipe, the DATA sockets are used strictly for Minecraft packets only, and the SIGNAL soocket is used for relay to host signaling only.</p>
<p>I have illustrated both models here:</p>
<pre><code>Traditional Networking Model of Relays

Host ───────────────────── Relay ──────────────────── Clients

                         ┌───────┐
                         │       │ &lt;─── DATA ────&gt; [ Client 1 ]
┌──────┐                 │ RELAY │ &lt;─── DATA ────&gt; [ Client 2 ]
│ HOST │ &lt;─── DATA ────&gt; │       │ &lt;─── DATA ────&gt; [ Client 3 ]
└──────┘                 │       │ &lt;─── DATA ────&gt; [ Client 4 ]
                         └───────┘

* May differ from mod to mod. Some mods use P2P instead, which doesn't need a relay.
</code></pre>
<p>Here's the networking model used in StealthPipe (version 3.0.0 and higher):</p>
<pre><code>
StealthPipe Networking Model (Parallel Connections &gt;=v3.0.0)

Host ───────────────────── Relay ──────────────────── Clients

┌──────┐                 ┌───────┐
│      │ &lt;─── DATA ────&gt; │       │ &lt;─── DATA ────&gt; [ Client 1 ]
│      │ &lt;─── DATA ────&gt; │       │ &lt;─── DATA ────&gt; [ Client 2 ]
│ HOST │ &lt;─── DATA ────&gt; │ RELAY │ &lt;─── DATA ────&gt; [ Client 3 ]
│      │ &lt;─── DATA ────&gt; │       │ &lt;─── DATA ────&gt; [ Client 4 ]
│      │ &lt;== SIGNAL ===&gt; │       │
└──────┘                 └───────┘

</code></pre>
<p>This allows the relay to process each client independently in multiple threads. Here's why this is likely more efficient:</p>
<p>Minecraft sends around 500 packets per second per player. If one player is connected to the room, 500 packets per second go through the DATA channel. However, if 10 players are connected, 5000 packets go through the DATA channel, which is significantly more for the relay to handle in a single thread. Also, WebSockets are hardly thread-safe, so all the clients sending 50 packets/second must also compete for a single lock to write to that single DATA socket going to the relay. Finally, when the HOST sends a message, it also needs to know WHERE to send this packet, which most likely requires extra parsing and header to determine which socket should receive this data. The biggest downside to this architecture is a slightly higher use of RAM and more context switching on the CPU when the number of cores is limited.</p>
<p>In this architecture, the SIGNAL is used to notify the host when a new player joins, and asks it to create a DATA connection to the relay. Then, we link the host's DATA connection to the client's DATA connection. This means that even if we have 10 players sending 500 packets each, a single thread won't be handling them all, since each client has a corresponding host -&gt; relay connection and a relay -&gt; client connection, allowing each thread to only handle 500 packets each, improving performance. Also, there is no need for extra metadata, parsing or header since each thread already knows where to forward the packets.</p>
<p>In the traditional single-connection model, if one player experiences a packet loss, the TCP window stalls for all players (Head-of-Line blocking). StealthPipe V3's parallel architecture ensures that one player's lag does not affect anyone else in the room.</p>
<p>Suprisingly, e4mc uses a version of this parallel model. It uses QUIC (UDP) which allows it to have multiple streams without having multiple connections. UDP is faster than WebSockets (TCP) but it most likely won't work in the harsh environments StealthPipe needs to face, since QUIC looks like a VPN. In terms of raw performance, e4mc is likely faster if it works, but it may be throttled in some environments. In summary, they still use a single connection, but are able to create multiple streams natively with QUIC.</p>
<h3 id="packet-batching">Packet Batching</h3>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p>This feature is only available in version 5.0.0 and onwards.</p>
</div>
<p>In version 5.0.0, the packets are batched in 1ms intervals. What this means is that each time a packet is sent, it will queue it instead of sending it directly. Then, it will check if the last time a batch was sent was more than 1ms ago.</p>
<p>If this is true, it will batch all queued packets together and send them in one batch. This simple method reduces the number of packets per second by 10 times. The reason such a simple method and a short timeframe of 1ms has such a great effect is because Minecraft frequently sends out bursts of packets in microseconds instead of many packets spread throughout the entire tick.</p>
<p>This feature, however, adds latency that can vary from 8ms to over 30 milliseconds. On average, the added latency is around 20 milliseconds. This added ping does not depend on geographical location, but rather depends on pure luck from my testing.</p>
<div class="markdown-alert markdown-alert-warning"><p class="markdown-alert-title"><svg class="octicon octicon-alert mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p><p>Version 5.0.0 and the batching feature are still experimental. We will attempt to decrease the added latency caused by packet batching, but this is still an ongoing issue.</p>
</div>
<h3 id="handling-relay-restarts">Handling Relay Restarts</h3>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p>Relay Restarts are only handled in version 4.1.0 and onwards.</p>
</div>
<p>The default relay is hosted on <a href="http://Render.com">Render.com</a> on the free tier and that means that they will move the instance on their clusters when they feel like it. For normal HTTP applications, this is not a big issue because HTTP connections are not long-lasting and are closed immediately after the request is completed. However, for WebSockets, this is a bigger issue since they can last for many hours and are hard to transfer without a lot of load balancing infrastructure (which is far too complex and expensive for something like StealthPipe). These restarts are suprinsingly common (around every 10-15 minutes), so we need to find a solution that will handle relay restarts more gracefully instead of completely nuking the room and restarting from scratch each time as it gets annoying quick for the players.</p>
<p>Before version 4.1.0, hosts are disconnected, which closes the whole room to close because the SIGNAL connection was lost. The host then had to rejoin the world and create a new room, which caused the creation of a new room code. After, they had to share this new link with the rest of the players, which caused a lot of headaches since relays can be restarted every 10 minutes.</p>
<p>But in version 4.1.0 and onwards, the host will attempt to reconnect to the relay using the same room code. Clients will still be disconnected, but this is at least a step forward in the right direction. Like you probably saw, the server now returns a reuse token on the <code>create</code> endpoint. This allows the host to pass this token as an argument when creating a room code to tell the relay to reuse the same room code that it had used before if it hasn't been taken by someone else yet. This can be done infinitely until the reuse token expires (1 hour).</p>
<h3 id="handshake-protocol-questions">Handshake Protocol Questions</h3>
<p><strong>Why Proof of Work?</strong>
Since StealthPipe does not require any authentication, and the computational resources are rather limited, we require a proof of work to prevent bots or scripts from easily exceeding our computational budget. By requiring proof of work, the clients must &quot;pay&quot; by doing work before they can create a new room, slowing down scripts and bots tremendously.</p>
<p>Here's how Proof of Work protects our relay:
<strong>Before</strong>: A Python script that is 50 lines long could easily create 1 million connections in a few minutes.
<strong>After</strong>: The same Python script would take multiple hours to create 200 connections, let alone 1 million. They must optimize their code using multi-threading, but the dynamic difficulty system makes it harder the more requests you send.</p>
<p><strong>How is Proof of Work done?</strong></p>
<p>It is done by finding a SHA-256 hash using the relay's salt with an X number of zeroes, where X is the difficulty given by the relay. Once it finds one, it reports the nonce to the relay so it can validate it and allow the client to create a room. The difficulty increases depending on the number of create requests received per second, essentially throttling traffic while not using IP addresses (which are sometimes not accurate enough to distinguish between different users). PoW terminates immediately after room creation. There is no background mining.
Source can be found in <code>RelayConnector.java</code> in <code>checkPoW</code> and <code>doProofOfWorkChallenge</code> methods.</p>
<p><strong>Why not just use IP addresses?</strong></p>
<p>IP-based limiting is ineffective in airports or hotels where 500 people may share a single Public IP. PoW allows us to rate-limit per-device without needing accounts or tracking user data.</p>
<h3 id="data-encapsulation--relaying-model">Data Encapsulation &amp; Relaying Model</h3>
<p>A simple diagram showing how data is relayed (nothing special here):</p>
<pre><code>
┌─────────────────────────────────────────────────┐
│  HOST               RELAY               CLIENT  │
├───────────────────────┬─────────────────────────┤
│                       │                         │
│─── Encrypted data ───&gt;│                         │
│      [Payload]        │─── Encrypted data ─────&gt;│
│                       │       [Payload]         │
│                       │                         │
│                       │&lt;─── Encrypted data ─────│
│&lt;── Encrypted data ────│       [Payload]         │
│      [Payload]        │                         │
└───────────────────────┴─────────────────────────┘

* Data is only encrypted by Minecraft if the client is using Online mode. 
  But StealthPipe does not attempt to read, decrypt or decode the payload
  whether it is encrypted or not.
</code></pre>
<p>Most tunneling mods that rely on relays use this model.</p>
<h3 id="hooking-into-the-netty-pipeline">Hooking into the Netty Pipeline</h3>
<p>Each connection (a real one) has a Netty Channel associated with it. It is basically an abstraction of an underlying network socket, to put it simply. And each channel has a pipeline, a series of steps that a packet must go through to get serialized. To make StealthPipe work, it injects a custom <code>DuplexHandler</code> at the end of the pipeline to intercept the binary data before it proceeds to send it. Later, you'll also learn that we make use of Embedded Channels (basically fake channels) to trick Minecraft into thinking that it is a real network connection and route data through it. Embedded Channels are meant for testing, but for StealthPipe, they are used to pipe Minecraft packets to the relay.</p>
<pre><code>
Sending a packet:

   [ External class ]
           │
           │                                         
           V                                             
Netty: [ Beginning ] ─────&gt; [...] ─────&gt; [ StealthPipe ] ─────&gt; Sent
      ( Packet class )                      ( Binary )          nowhere
                                                │
                                                │
                                                V
                                           Sent to Relay
                                              via WSS       

* [...] represents the series of steps to get the Packet class serialized, such as
  encryption, packet encoding, and compression. So by the time StealthPipe gets
  the binary, it is already encrypted by Minecraft, which means the data is
  unreadable by StealthPipe.

</code></pre>
<pre><code class="language-mermaid">flowchart LR

    A[&quot;External class&quot;]
    B[&quot;Netty (Packet class)&quot;]
    C[&quot;...&quot;]
    D[&quot;StealthPipe (Binary)&quot;]
    E[&quot;Sent nowhere&quot;]
    F[&quot;Relay via WSS&quot;]

    A --&gt; B
    B --&gt; C
    C --&gt; D
    D --&gt; E
    D --&gt; F
</code></pre>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p>[...] represents the series of steps to get the Packet class serialized, such as
encryption, packet encoding, and compression. So by the time StealthPipe gets
the binary, it is already encrypted by Minecraft, which means the data is
unreadable by StealthPipe.</p>
</div>
<p>StealthPipe injects its own <code>DuplexHandler</code> at the end of the pipeline to intercept the binary data and send it off to the relay. At that point, the data is already fully serialized, encrypted and ready to be sent off. StealthPipe clones the data and sends it to the relay. The original pipeline continues to its conclusion, but because the channel is 'fake' (Embedded), the data is simply discarded by the system after leaving the pipeline. Why fake channels? Because without them, Minecraft refuses to accept the connection or initiate its handshake.</p>
<p>Receiving is basically the same thing, except the steps are reversed and StealthPipe injects data at the first step instead of intercepting at the end.</p>
<p>On the server, one new fake channel is created per player, tricking Minecraft into believing they are actually connected to your LAN world. On the client, we trick Minecraft to use our fake <code>Connection</code>Subtracting object which internally also uses a fake channel.</p>

            
            
        </body>
        </html>